#!/usr/bin/env python3
"""
Recipe Manifest Builder

Scans recipe .md files in the recipes/ directory, extracts YAML-style
frontmatter from each, and generates recipes/manifest.md as a searchable
markdown table.

Usage:
    python tools/build_recipe_manifest.py
    python tools/build_recipe_manifest.py --recipes-dir /path/to/recipes
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# ============================================================================
# CONSTANTS
# ============================================================================

PROJECT_ROOT = Path(__file__).parent.parent

REQUIRED_FIELDS = {"name", "category", "tags", "summary"}
OPTIONAL_FIELDS = {"patterns", "depends"}
ALL_FIELDS = REQUIRED_FIELDS | OPTIONAL_FIELDS
LIST_FIELDS = {"tags", "patterns", "depends"}

SKIP_FILES = {"manifest.md", "patterns.md"}


# ============================================================================
# FRONTMATTER PARSING
# ============================================================================

def parse_list_value(raw: str) -> List[str]:
    """Parse a bracketed list value like [item1, item2, item3] into a list of strings."""
    raw = raw.strip()
    if raw.startswith("[") and raw.endswith("]"):
        inner = raw[1:-1]
        if not inner.strip():
            return []
        return [item.strip() for item in inner.split(",") if item.strip()]
    # Single value without brackets
    if raw:
        return [raw]
    return []


def parse_frontmatter(content: str) -> Tuple[Optional[Dict[str, any]], Optional[str]]:
    """
    Extract YAML-style frontmatter from markdown content.

    Returns:
        (parsed_dict, error_message) — one of the two will be None.
    """
    lines = content.split("\n")

    # Must start with ---
    if not lines or lines[0].strip() != "---":
        return None, "no frontmatter found (file must start with ---)"

    # Find closing ---
    end_index = None
    for i in range(1, len(lines)):
        if lines[i].strip() == "---":
            end_index = i
            break

    if end_index is None:
        return None, "no closing --- delimiter for frontmatter"

    # Parse key: value pairs
    data: Dict[str, any] = {}
    for line_num, line in enumerate(lines[1:end_index], start=2):
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        match = re.match(r"^(\w+)\s*:\s*(.*)$", line)
        if not match:
            return None, f"line {line_num}: invalid frontmatter syntax: {line!r}"

        key = match.group(1)
        value = match.group(2).strip()

        if key not in ALL_FIELDS:
            return None, f"line {line_num}: unknown field {key!r} (valid: {', '.join(sorted(ALL_FIELDS))})"

        if key in LIST_FIELDS:
            data[key] = parse_list_value(value)
        else:
            data[key] = value

    return data, None


def validate_frontmatter(data: Dict[str, any], filepath: Path) -> List[str]:
    """Check that all required fields are present and non-empty."""
    errors = []
    for field in sorted(REQUIRED_FIELDS):
        if field not in data:
            errors.append(f"missing required field: {field}")
        elif isinstance(data[field], str) and not data[field]:
            errors.append(f"empty required field: {field}")
        elif isinstance(data[field], list) and len(data[field]) == 0:
            errors.append(f"empty required field: {field}")
    return errors


# ============================================================================
# RECIPE ENTRY
# ============================================================================

class RecipeEntry:
    """Parsed recipe with all frontmatter fields and file path."""

    def __init__(self, data: Dict[str, any], rel_path: str):
        self.name: str = data["name"]
        self.category: str = data["category"]
        self.tags: List[str] = data.get("tags", [])
        self.patterns: List[str] = data.get("patterns", [])
        self.depends: List[str] = data.get("depends", [])
        self.summary: str = data["summary"]
        self.rel_path: str = rel_path

    @property
    def sort_key(self) -> Tuple[str, str]:
        return (self.category.lower(), self.name.lower())


# ============================================================================
# MANIFEST GENERATION
# ============================================================================

def build_manifest_md(entries: List[RecipeEntry]) -> str:
    """Generate the manifest.md content as a markdown table."""
    lines = [
        "# Recipe Manifest",
        "<!-- Auto-generated by tools/build_recipe_manifest.py — do not edit manually -->",
        "<!-- Search with: Grep pattern=\"keyword\" path=\"recipes/manifest.md\" -->",
        "",
        "| Recipe | Category | Tags | Patterns | Summary | Path |",
        "|--------|----------|------|----------|---------|------|",
    ]

    for entry in sorted(entries, key=lambda e: e.sort_key):
        tags_str = ", ".join(entry.tags)
        patterns_str = ", ".join(entry.patterns) if entry.patterns else "—"
        lines.append(
            f"| {entry.name} | {entry.category} | {tags_str} | {patterns_str} | {entry.summary} | {entry.rel_path} |"
        )

    lines.append("")  # trailing newline
    return "\n".join(lines)


# ============================================================================
# SCANNING
# ============================================================================

def scan_recipes(recipes_dir: Path) -> Tuple[List[RecipeEntry], List[str]]:
    """
    Recursively scan recipes_dir for .md files, parse frontmatter, validate.

    Returns:
        (entries, errors) — errors are formatted as "path: message".
    """
    entries: List[RecipeEntry] = []
    errors: List[str] = []

    if not recipes_dir.is_dir():
        errors.append(f"{recipes_dir}: directory not found")
        return entries, errors

    md_files = sorted(recipes_dir.rglob("*.md"))

    for filepath in md_files:
        # Skip manifest.md and patterns.md anywhere in the tree
        if filepath.name.lower() in SKIP_FILES:
            continue

        rel_path = filepath.relative_to(recipes_dir)
        rel_str = str(rel_path)

        try:
            content = filepath.read_text(encoding="utf-8")
        except OSError as e:
            errors.append(f"{rel_str}: could not read file: {e}")
            continue

        data, parse_error = parse_frontmatter(content)
        if parse_error:
            errors.append(f"{rel_str}: {parse_error}")
            continue

        validation_errors = validate_frontmatter(data, filepath)
        if validation_errors:
            for ve in validation_errors:
                errors.append(f"{rel_str}: {ve}")
            continue

        entries.append(RecipeEntry(data, rel_str))

    return entries, errors


# ============================================================================
# MAIN
# ============================================================================

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Build recipes/manifest.md from recipe frontmatter."
    )
    parser.add_argument(
        "--recipes-dir",
        type=Path,
        default=PROJECT_ROOT / "recipes",
        help="Path to the recipes directory (default: recipes/ relative to project root)",
    )
    args = parser.parse_args()

    recipes_dir: Path = args.recipes_dir.resolve()

    print(f"Scanning: {recipes_dir}")

    entries, errors = scan_recipes(recipes_dir)

    # Report errors
    if errors:
        print(f"\nValidation errors ({len(errors)}):")
        for err in errors:
            print(f"  ERROR  {err}")

    # Always write manifest (even with 0 entries — produces header-only table)
    manifest_path = recipes_dir / "manifest.md"
    manifest_content = build_manifest_md(entries)
    manifest_path.write_text(manifest_content, encoding="utf-8")
    print(f"\nWrote {manifest_path} ({len(entries)} entries)")

    # Summary
    print(f"\nProcessed: {len(entries)} recipes")
    if errors:
        print(f"Errors:    {len(errors)}")
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
